<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Intel:针对ROP攻击的新硬件特性 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1 针对ROP/JOP/COP的intel特性ROP/JOP/COP攻击通常有两个特性：第一是包含执行特权命令的代码片段，至少包含一条控制流转移指令，其转移目的由返回stack或者寄存器中的目标地址决定；第二是它们将控制流指令(RET，CALL，JMP)的地址修改到新的目标地址。intel提供Shadow Stack和Indirect branch tracking两种功能，来防御这一类攻击。Sh">
<meta name="keywords" content="linux,intel,硬件">
<meta property="og:type" content="article">
<meta property="og:title" content="Intel:针对ROP攻击的新硬件特性">
<meta property="og:url" content="http://yoursite.com/2016/06/13/Intel：针对ROP攻击的特性/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 针对ROP/JOP/COP的intel特性ROP/JOP/COP攻击通常有两个特性：第一是包含执行特权命令的代码片段，至少包含一条控制流转移指令，其转移目的由返回stack或者寄存器中的目标地址决定；第二是它们将控制流指令(RET，CALL，JMP)的地址修改到新的目标地址。intel提供Shadow Stack和Indirect branch tracking两种功能，来防御这一类攻击。Sh">
<meta property="og:updated_time" content="2017-07-28T09:04:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Intel:针对ROP攻击的新硬件特性">
<meta name="twitter:description" content="1 针对ROP/JOP/COP的intel特性ROP/JOP/COP攻击通常有两个特性：第一是包含执行特权命令的代码片段，至少包含一条控制流转移指令，其转移目的由返回stack或者寄存器中的目标地址决定；第二是它们将控制流指令(RET，CALL，JMP)的地址修改到新的目标地址。intel提供Shadow Stack和Indirect branch tracking两种功能，来防御这一类攻击。Sh">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Intel：针对ROP攻击的特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/13/Intel：针对ROP攻击的特性/" class="article-date">
  <time datetime="2016-06-13T09:40:00.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Intel:针对ROP攻击的新硬件特性
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-针对ROP-JOP-COP的intel特性"><a href="#1-针对ROP-JOP-COP的intel特性" class="headerlink" title="1 针对ROP/JOP/COP的intel特性"></a>1 针对ROP/JOP/COP的intel特性</h3><p>ROP/JOP/COP攻击通常有两个特性：第一是包含执行特权命令的代码片段，至少包含一条控制流转移指令，其转移目的由返回stack或者寄存器中的目标地址决定；第二是它们将控制流指令(RET，CALL，JMP)的地址修改到新的目标地址。<br>intel提供Shadow Stack和Indirect branch tracking两种功能，来防御这一类攻击。Shadow Stack提供返回地址的保护，使程序免遭ROP攻击的影响；Indirect branch tracking提供分支保护，来防御JOP/COP攻击。  </p>
<h5 id="1-1-Shadow-Stack"><a href="#1-1-Shadow-Stack" class="headerlink" title="1.1 Shadow Stack"></a>1.1 Shadow Stack</h5><p>shadow stack是仅仅用来实现控制流转移的“第二个”stack，它和data stack分离。当shadow stack被激活时，CALL指令会把返回地址同时push进data stack和shadow stack中。在RET指令执行时，两个stack中的值都会pop出来，并进行一次比较，如果这两个值不相同，那么处理器就会发出一个control protection exception。</p>
<h5 id="1-2-Indirect-branch-tracking"><a href="#1-2-Indirect-branch-tracking" class="headerlink" title="1.2 Indirect branch tracking"></a>1.2 Indirect branch tracking</h5><p>ENDBRANCH是一个新的指令，它被用来标识合法的indirect call/jmp指令。在不支持CET的机器上，这个指令被翻译为一个NOP指令；在支持CET的处理器上，它依然是一个NOP指令，它主要被用做一个标记指令，用来标记处理器管道中有序的部分，来检测控制流的错误。CPU会实现一个状态及，来追踪jmp和call指令，一旦某个这类指令被发现了，状态机就从IDLE跳转到WAIT_FOR_ENDBRACH状态。在这个状态下，下一条指令必须是ENDBRANCH。如果下一条指令不是ENDBRANCH，那么处理器就制造一个control protection fault。  </p>
<h3 id="2-Shadow-stacks环境"><a href="#2-Shadow-stacks环境" class="headerlink" title="2 Shadow stacks环境"></a>2 Shadow stacks环境</h3><p>shadow stack的读写是被严格限制的，它只能由控制流转移指令和shadow stack管理指令来完成。它能在user mode(CPL == 3)和supervisor mode(CPL &lt; 3)中分别打开。shadow stacks必须在开启分页功能的保护模式下使用。<br>使用shadow stack时，处理器会支持一个新的寄存器，shadow stack pointer(SSP)，它不能被直接编码为指令中的源地址、目的地址、随机内存地址等。它指向shadow stack的顶部。它保存的是一个线性地址，并通过FAR RET，IRET和RSTORSSP指令来装载入寄存器中。它的大小根据当前的mode确定为32bit或64bit。  </p>
<h5 id="2-1-Near-CALL-RET"><a href="#2-1-Near-CALL-RET" class="headerlink" title="2.1 Near CALL/RET"></a>2.1 Near CALL/RET</h5><p>激活shadow stack时，Near CALL会将返回地址同时push到data stack和shadow stack中去，Near RET会将返回地址同时从data stack和shadow stack中pop出来。如果两者的返回地址不同，则触发near-ret异常。  </p>
<h5 id="2-2-Far-CALL-RET"><a href="#2-2-Far-CALL-RET" class="headerlink" title="2.2 Far CALL/RET"></a>2.2 Far CALL/RET</h5><p>激活shadow stack时，Far CALL会将CS，LIP(linear address of return address)以及SSP三者push到shadow stack上，并在far RET的时候按SSP，LIP和CS的顺序pop。如果CS和LIP的值和CS以及EIP中的返回地址值不符合，就会触发FAR-RET/IRET异常。<br>far CALL到更高权限的过程如下：<br>当far CALL处于user mode(CPL3)时，返回地址不被push到supervisor shadow stack。相似的，一个从更高权限(CPL&lt;3)回到CPL3的far RET也不会对返回地址进行验证。CPL3到CPL&lt;3的过程中，user space SSP会被保存在一个MSR寄存器中，在CPL&lt;3到CPL3的过程中，利用这个寄存器可以恢复user space SSP。<br>对于不同权限之间的call，call指令会进行一次stack的切换。supervisor程序的data stack位于当前的TSS段。相似的，shadow stack也进行这种切换。根据权限的不同(ring 0, ring 1, ring 2)，supervisor程序会选择不同的MSR来获取SSP。<br>从ring 2到ring 1，从ring 2 到ring 0或者从ring 1到ring 0被认为是“同样权限级别”之间的切换。也就是说，对于这样的calls，会将调用者程序短的CS，LIP和SSP push到被调用程序段的shadow stack上，而在far RET时，会验证其中的CS和LIP是否和data stack中的CS和EIP是一致的。<br>对于一个不同权限级别之间的far CALL，CET会验证一个“supervisor shadow stack token”。这个token在shadow stacks创建的时候，由supervisor设置，是一个64bit的值。这个token中，有效部分有两个，其一是63:3bit，它们是这个token的地址；其二是第一个bit(busy bit)，它表明了对应的shadow stack是否在使用。<br>在far CALL时，首先根据IA32_Plx_SSP中的地址，获取对应的token；随后判断它的busy bit是否为0，并且检查MSR中的地址和token中的是否吻合。吻合的话要将busy bit设置为1，并且切换SSP。<br>在far RET时，首先通过SSP加载token，随后检查token的busy bit是否为1，并且检查token是否和SSP一致。如果通过，则要清除busy bit位。  </p>
<h5 id="2-3-Interrupt-Exception"><a href="#2-3-Interrupt-Exception" class="headerlink" title="2.3 Interrupt/Exception"></a>2.3 Interrupt/Exception</h5><p>64bit模式提供了一种stack切换机制，称为Interrupt stack table(IST)，其中的64bit IDT能够被用来在无权限变化发生时，指定64bit TSS中7个data stack指针中的一个。如果IST索引是0，说明没有权限变化，stack会切换到同一个stack。<br>为了支持这个stack切换机制，shadow stack提供了一个MSR，IA32_INTERRUPT_SSP_TABLE，用来存放一个表的线性地址，它包含7个shadow stack指针。如果是一个非0的IST值，并且在call的过程中没有发生权限变化，那么MSR就指向内存中的一个64byte表，这个表利用IST来作索引。</p>
<h5 id="2-4-Shadow-Stack-amp-Task-Switch"><a href="#2-4-Shadow-Stack-amp-Task-Switch" class="headerlink" title="2.4 Shadow Stack&amp;Task Switch"></a>2.4 Shadow Stack&amp;Task Switch</h5><p>task切换能够通过三种方法完成：  </p>
<ul>
<li>JMP/CALL GDT中的TSS描述符  </li>
<li>JMP/CALL GDT中的task-gate描述符或当前的LDT  </li>
<li>一个interrupt或exception向量，指向IDT中中的task-gate描述符  </li>
</ul>
<p>在激活shadow stack的情况下，一个新的task必须与一个32bit TSS关联，并且不能工作在8086虚模式。32bit的新task的SSP，位于32bit TSS的偏移量104bytes处。因此新task的TSS至少要在108bytes的位置。SSP必须是8bytes对齐的，并且指向shadow stack token。<br>一个用CALL指令实现的嵌套task切换，旧task的SSP不会保存到旧进程的TSS，而是和CS与LIP一起，被push到新task的shadow stack。类似的，一个以IRET实现的非(解)嵌套task切换，新task的SSP被从旧task的shadow stack中恢复。如果旧shadow stack中CS和LIP与新taskCS和EIP所决定的返回地址一致，说明控制流正确，如果不吻合，就会出现异常。    </p>
<h3 id="3-Indirect-branch环境"><a href="#3-Indirect-branch环境" class="headerlink" title="3 Indirect branch环境"></a>3 Indirect branch环境</h3><p>当indirect branch traking特性被激活时，indirect jmp/call指令的过程会做出相应的改变。<br>jmp:如果indirect jmp的下一条指令不是ENDBR32指令(在遗留以及兼容模式)，或者ENDBR64指令，就产生#CP异常。只有以下形式的jmp指令会被跟踪：</p>
<ul>
<li>jmp r/m16, r/m32, r/m64  </li>
<li>jmp m16:16, m16:32, m16:64  </li>
</ul>
<p>call:如果indirect call的下一条指令不是ENDBR32指令(在遗留以及兼容模式)，或者ENDBR64指令，就产生#CP异常。只有以下形式的call指令会被跟踪：</p>
<ul>
<li>call r/m16, r/m32, r/m64  </li>
<li>call m16:16, m16:32, m16:64</li>
</ul>
<p>ENDBRANCH在支持/不支持CET的机器上，都不会造成任何执行上的影响。唯一的区别是，支持CET的处理器上，实现了一个2个状态的状态机，用来跟踪indirect call/jmp。在user mode和supervisor mode，各有一个这样的状态机。在除indirect call和jmp指令之外的指令时，状态机状态保持在IDLE；在indirect call和jmp指令时，状态机切换到WAIT_FOR_ENDBRANCH。在WAIT_FOR_ENDBRANCH状态下，只允许下一条指令是ENDBRANCH，或者兼容模式下的某些指令。<br>当#CP(ENDBRANCH)异常发生时，高优先级的异常会先于#CP异常发生。在将控制流转交给异常handler时，高权限的状态机会保持原状态，指令指针压入堆栈中的是引发异常的indirect call/jmp的指令地址。  </p>
<h5 id="3-1-不追踪前缀：3EH"><a href="#3-1-不追踪前缀：3EH" class="headerlink" title="3.1 不追踪前缀：3EH"></a>3.1 不追踪前缀：3EH</h5><p>使用寄存器的Near indirect call/jmp指令，如果有3EH前缀，就说明这个控制流不需要被追踪。但Far call/jmp，以及使用内存地址的Near indirect call/jmp，即使有3EH前缀，也会忽略掉这个前缀，总是被追踪。  </p>
<h5 id="3-2-CPL-3和CPL-lt-3之间的控制流转移"><a href="#3-2-CPL-3和CPL-lt-3之间的控制流转移" class="headerlink" title="3.2 CPL 3和CPL&lt;3之间的控制流转移"></a>3.2 CPL 3和CPL&lt;3之间的控制流转移</h5><p>硬件实现了两个CET状态机：user mode和supervisor mode各有一个。当前使用哪个状态机，是根据此时CPL的值来决定的。当从CPL3切换到CPL&lt;3时，会停用user mode的状态机，转而使用supervisor mode的状态机，反之亦然。<br>在任何情况下，源状态机变成不激活状态，并且保存它的原有状态，如果没有异常情况，目标状态机激活。具体情况有以下几类：  </p>
<ul>
<li>Far call/jmp，SYSCALL/SYSENTER:tracker被激活，解除禁止，并转移到WAIT_FOR_ENDBRANCH，强迫far call/jump之后必须跟随着ENDBRACH。  </li>
<li>Hardware interrupt/trap/exception/NMI/Software interrupt/Machine Checks:traker被激活，解除禁止并转移到WAIT_FOR_ENDBRANCH。  </li>
<li>iret:tracker被激活，并且保持原有状态。  </li>
</ul>
<h5 id="3-3-CPL-3和CPL-lt-3内部的控制流转移"><a href="#3-3-CPL-3和CPL-lt-3内部的控制流转移" class="headerlink" title="3.3 CPL 3和CPL&lt;3内部的控制流转移"></a>3.3 CPL 3和CPL&lt;3内部的控制流转移</h5><p>在同一个权限内发生控制流转移时，在控制流转移前后，不切换状态机。具体情况可分为以下几类：  </p>
<ul>
<li>FAR CALL/JMP:tracker解除禁止，并转移到WAIT_FOR_ENDBRANCH</li>
<li>Near indirect call/jmp:如果tracker没有被禁止，转移到WAIT_FOR_ENDBRANCH</li>
<li>Hardware interrupt/trap/exception/NMI/Software interrupt/Machine Checks:tracker unsuppressed，转移到WAIT_FOR_ENDBRACH</li>
<li>iret:激活的tracker保持其状态</li>
</ul>
<h5 id="3-4-INT3-处理"><a href="#3-4-INT3-处理" class="headerlink" title="3.4 INT3 处理"></a>3.4 INT3 处理</h5><p>INT3在WAIT_FOR_ENDBRANCH中被特别处理。INT3的出现不会将tracker移动到IDLE状态，而INT3引发的#BP trap被作为一个更高优先级的事件处理，从而忽略了ENDBRANCH。  </p>
<h5 id="3-5-与遗留系统兼容"><a href="#3-5-与遗留系统兼容" class="headerlink" title="3.5 与遗留系统兼容"></a>3.5 与遗留系统兼容</h5><p>启用了CET的程序在满足条件的情况下，能够对遗留系统保持兼容性。首先，通过设置LEG_IW_EN位，可以开启遗留系统的兼容选项；其次，控制流的转移通过indirect call/jmp到non-endbranch的形式实现；第三，legacy code page bitmap被设置成指明目标控制流是遗留代码页。<br>其中，legacy code page bitmap是一个程序内存中的数据结构，用来给硬件决定一个控制流转移是否是到遗留代码页的。这个bitmap的地址由EB_LEG_BITMAP_BASE，bitmap中的每个bit代表了线性内存中的一个4k页。如果bit是1，说明对应的代码页是遗留的代码页，否则它是一个启用了CET的代码页。线性地址的bits 31:12被用作这个bitmap的索引。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/13/Intel：针对ROP攻击的特性/" data-id="cj5nn8993001ooc3fb14v3v5t" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/intel/">intel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/硬件/">硬件</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/15/Intel VT-x:EPT解读/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          VT-x/EPT解读
        
      </div>
    </a>
  
  
    <a href="/2016/06/08/I:O与page cache/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">详解页缓存page cache</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GCC/">GCC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/">I/O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDA-pro/">IDA pro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVM/">KVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ocaml/">Ocaml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PID-namespace/">PID namespace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGX/">SGX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binutils/">binutils</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome/">chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/container/">container</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/intel/">intel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kvm/">kvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux内核/">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/llvm/">llvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory/">memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/namespace/">namespace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/server/">server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x64-assembly/">x64 assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/x86-64/">x86-64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二进制/">二进制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存安全/">内存安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/底层安全/">底层安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件系统/">文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器安全/">浏览器安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/硬件/">硬件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统安全/">系统安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译器/">编译器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译安全/">编译安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚函数/">虚函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链接器/">链接器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/静态分析/">静态分析</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/GCC/" style="font-size: 17.14px;">GCC</a> <a href="/tags/I-O/" style="font-size: 11.43px;">I/O</a> <a href="/tags/IDA-pro/" style="font-size: 10px;">IDA pro</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Ocaml/" style="font-size: 11.43px;">Ocaml</a> <a href="/tags/PID-namespace/" style="font-size: 10px;">PID namespace</a> <a href="/tags/QEMU/" style="font-size: 10px;">QEMU</a> <a href="/tags/SGX/" style="font-size: 12.86px;">SGX</a> <a href="/tags/binutils/" style="font-size: 10px;">binutils</a> <a href="/tags/chrome/" style="font-size: 10px;">chrome</a> <a href="/tags/container/" style="font-size: 10px;">container</a> <a href="/tags/intel/" style="font-size: 11.43px;">intel</a> <a href="/tags/kvm/" style="font-size: 10px;">kvm</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/linux内核/" style="font-size: 12.86px;">linux内核</a> <a href="/tags/llvm/" style="font-size: 10px;">llvm</a> <a href="/tags/memory/" style="font-size: 10px;">memory</a> <a href="/tags/namespace/" style="font-size: 11.43px;">namespace</a> <a href="/tags/nginx/" style="font-size: 11.43px;">nginx</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/server/" style="font-size: 11.43px;">server</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/x64-assembly/" style="font-size: 11.43px;">x64 assembly</a> <a href="/tags/x86-64/" style="font-size: 10px;">x86-64</a> <a href="/tags/二进制/" style="font-size: 10px;">二进制</a> <a href="/tags/内存安全/" style="font-size: 10px;">内存安全</a> <a href="/tags/底层安全/" style="font-size: 10px;">底层安全</a> <a href="/tags/操作系统/" style="font-size: 18.57px;">操作系统</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/浏览器安全/" style="font-size: 10px;">浏览器安全</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/硬件/" style="font-size: 10px;">硬件</a> <a href="/tags/系统安全/" style="font-size: 12.86px;">系统安全</a> <a href="/tags/编译器/" style="font-size: 11.43px;">编译器</a> <a href="/tags/编译安全/" style="font-size: 15.71px;">编译安全</a> <a href="/tags/虚函数/" style="font-size: 10px;">虚函数</a> <a href="/tags/虚拟化/" style="font-size: 14.29px;">虚拟化</a> <a href="/tags/链接器/" style="font-size: 10px;">链接器</a> <a href="/tags/静态分析/" style="font-size: 12.86px;">静态分析</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/15/浅谈GCC编译优化/">浅谈GCC编译优化</a>
          </li>
        
          <li>
            <a href="/2017/06/27/虚函数，原理和攻击方式/">从虚函数的实现，到虚表劫持攻击</a>
          </li>
        
          <li>
            <a href="/2017/06/19/编译链中的一环，静态链接详解/">编译链中的一环，静态链接详解</a>
          </li>
        
          <li>
            <a href="/2017/06/09/Hack gcc：添加新的函数/">Hack GCC，在编译时构造新的函数</a>
          </li>
        
          <li>
            <a href="/2017/05/16/Hack GCC：insturment on RTL/">Hack GCC，在RTL上插桩</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>